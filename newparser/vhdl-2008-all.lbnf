-- BNFC could use a rule for BNF's optional brackets
--

comment "--";

Absolute_Pathname ::= "." Partial_Pathname

AbstractLiteral . Abstract_Literal ::= Decimal_Literal;
AbstractLiteral . Abstract_Literal ::= Based_Literal;

Access_Type_Definition ::=
Access Subtype_Indication

ActualDesignatorInertial . Actual_Designator ::= "inertial" Expression;
ActualDesignatorExp . Actual_Designator ::= Expression;
ActualDesignatorName . Actual_Designator ::= Name;
ActualDesignatorSubtype . Actual_Designator ::= Subtype_Indication;
ActualDesignatorOpen . Actual_Designator ::= "open";

_ . Actual_Parameter_Part ::= Parameter_Association_List;

_ . Actual_part ::= Actual_Designator;
ActualPartName . Actual_part ::= Name "(" Actual_Designator ")";
ActualPartMark . Actual_part ::= Type_Mark "(" Actual_Designator ")";

Plus . Adding_Operator ::= "+";
Minus . Adding_Operator ::= "-";
Concat . Adding_Operator ::= "&";

separator Element_Association ",";
Aggregate ::= "(" [Element_Association] ")";

AliasDecl . Alias_Declaration ::=
          "alias" Alias_Designator "is" "name";
AliasDeclSig . Alias_Declaration ::=
             "alias" Alias_Designator "is" "name" Signature;
AliasDeclType . Alias_Declaration ::=
              "Alias" Alias_Designator ":" Subtype_Indication "is" "name";
AliasDeclTypeSig . Alias_Declaration ::=
                 "Alias" Alias_Designator ":" Subtype_Indication "is" "name" Signature ;

AliasDesignatorId . Alias_Designator ::= Identifier;
AliasDesignatorChar . Alias_Designator ::= Character_Literal;
AliasDesignatorOp . Alias_Designator ::= Operator_Symbol;

AllocatorSubtype . Allocator ::= New Subtype_Indication;
AllocatorQualified . Allocator ::= New Qualified_Expression;

ArchitectureBody . Architecture_Body ::=
                 "architecture" Identifier "of" Entity_Name
                 "is" Architecture_Declarative_Part
                 "begin" Architecture_Statement_Part "end";
ArchitectureBodyEA . Architecture_Body ::=
                 "architecture" Identifier "of" Entity_Name
                 "is" Architecture_Declarative_Part
                 "begin" Architecture_Statement_Part "end" "architecture"
ArchitectureBodyEID . Architecture_Body ::=
                 "architecture" Identifier "of" Entity_Name
                 "is" Architecture_Declarative_Part
                 "begin" Architecture_Statement_Part "end" Simple_Name;
ArchitectureBodyEAID . Architecture_Body ::=
                 "architecture" Identifier "of" Entity_Name
                 "is" Architecture_Declarative_Part
                 "begin" Architecture_Statement_Part "end" "architecture" Simple_Name;

terminator Block_Declarative_Item "";
terminator Concurrent_Statement "";

Architecture_Declarative_Part ::= [Block_Declarative_Item];
Architecture_Statement_Part ::= [Concurrent_Statement];

ArrayConstraintIdxcP . Array_Constraint ::= Index_Constraint Array_Element_Constraint;
ArrayConstraintIdxc . Array_Constraint ::= Index_Constraint;
ArrayConstraintOpenP . Array_Constraint ::= "(" "Open" ")" Array_Element_Constraint;
ArrayConstraintOpen . Array_Constraint ::= "(" "Open" ")";

_ . Array_Element_Constraint ::= Element_Constraint
_ . Array_Element_Resolution ::= Resolution_Indication

ArrayUnboundedDef . Array_Type_Definition ::= Unbounded_Array_Definition
ArrayConstrainedDef . Array_Type_Definition ::= Constrained_Array_Definition

Assertion . Assertion ::= "assert" Condition;
Assertion . Assertion ::= "assert" Condition Report Expression;
Assertion . Assertion ::= "assert" Condition Severity Expression;
Assertion . Assertion ::= "assert" Condition Report Expression Severity Expression;

LabeledAssertionStatement . Assertion_Statement ::= Label ":" Assertion ;
AssertionStatement . Assertion_Statement ::= Assertion ;

AssocElementBinary . Association_Element ::= Formal_Part "=>" Actual_Part;
AssocElementUnary . Association_Element ::= Actual_Part;

separator AssociationElement ",";

_ . Association_List ::= [AssociationElement];

_ . Attribute_Declaration ::= Attribute Identifier ":" Type_Mark ";";

_ . Attribute_Designator ::= Simple_Name;

AttributeName . Attribute_Name ::= Prefix "'" Attribute_Designator;
AttributeName . Attribute_Name ::= Prefix Signature "'" Attribute_Designator;
AttributeName . Attribute_Name ::= Prefix "'" Attribute_Designator "(" Expression ")";
AttributeName . Attribute_Name ::= Prefix Signature "'" Attribute_Designator "(" Expression ")";

AttrSpec . Attribute_Specification ::= "attribute" Attribute_Designator "of"
                        Entity_Specification "is" Expression ";";

_ . Base ::= Integer;

token Base_Specifier "("'B' | 'O' | 'X' | 'U' 'b' | 'U' 'o' | 'U' 'x' |
                      'S' 'b' | 'S' 'o' | 'S' 'x' | 'D');

-- TODO: Implement
--
-- Based_Integer ::= Extended_Digit { [ Underline ] Extended_Digit };
-- Based_Literal ::= Base # Based_Integer [ . Based_Integer ] # [ Exponent ]
-- Basic_Character ::= Basic_Graphic_Character | Format_Effector
-- Basic_Graphic_Character ::= Upper_Case_Letter | Digit | Special_Character| Space_Character
-- Bit_String_Literal ::= [ Integer ] Base_Specifier " [ Bit_Value ] "
-- Bit_Value ::= Graphic_Character { [ Underline ] Graphic_Character }

token Based_integer "("'d');
token Based_Literal "("'d');
token Basic_Character "("'d');
token Basic_Graphic_Character "("'d');
token Bit_String_Literal "("'d');
token Bit_Value "("'d');

BindingIndE . Binding_Indication ::= "use" Entity_Aspect ;
BindingIndEG . Binding_Indication ::= "use" Entity_Aspect  Generic_Map_Aspect ;
BindingIndEP . Binding_Indication ::= "use" Entity_Aspect  Port_Map_Aspect;
BindingIndEGP . Binding_Indication ::= "use" Entity_Aspect  Generic_Map_Aspect  Port_Map_Aspect;
BindingIndG . Binding_Indication ::= Generic_Map_Aspect ;
BindingIndGP . Binding_Indication ::= Generic_Map_Aspect  Port_Map_Aspect;
BindingIndP . Binding_Indication ::= Port_Map_Aspect;
BindingInd . Binding_Indication ::= ;

terminator Use_Clause "";
terminator Configuration_Item "";

Block_Configuration ::= "for" Block_Specification [Use_Clause] [Configuration_Item] "end" "for" ;

--
-- TODO
--

Block_Declarative_Item ::=
Subprogram_Declaration
| Subprogram_Body
| Subprogram_Instantiation_Declaration
| Package_Declaration
| Package_Body
| Package_Instantiation_Declaration
| Type_Declaration
| Subtype_Declaration
| Constant_Declaration
| Signal_Declaration
| Shared_Variable_Declaration
| File_Declaration
| Alias_Declaration
| Component_Declaration
| Attribute_Declaration
| Attribute_Specification
| Configuration_Specification
| Disconnection_Specification
| Use_Clause
| Group_Template_Declaration
| Group_Declaration

-- PSL stuff has been omitted

terminator Block_Declarative_Item "";

_ . Block_Declarative_Part ::= [Block_Declarative_Item];

BlockHeader . Block_Header ::= ;
BlockHeaderGeneric . Block_Header ::= BH_temp;
BlockHeaderPortmap . Block_Header ::= BH_temp2;
BlockHeaderGenericPortmap . Block_Header ::= BH_temp BH_temp2;

GenClauseGenMap . BH_temp ::= Generic_Clause Generic_Map_Aspect ";";
GenClause . BH_temp ::= Generic_Clause ";" ;
PortClausePortMap . BH_temp2 ::= Port_Clause Port_Map_Aspect";"
PortClause . BH_temp2 ::= Port_Clause ";"

Block_Specification ::= Architecture_Name
Block_Specification ::= Block_Statement_Label
Block_Specification ::= Generate_Statement_Label;
Block_Specification ::= Generate_Statement_Label "(" Generate_Specification ")";

Block_Statement ::=
Block_Label :
Block [ "(" Guard_Condition ")" ] [ Is ] Block_Header
Block_Declarative_Part
Begin
Block_Statement_Part End Block [ Block_Label ] ;

terminator Concurrent_Statement "";
separator Case_Generate_Alternative "";

Block_Statement_Part ::= [Concurrent_Statement];

CaseGenerateAlt . Case_Genreate_Alternative ::=
                "when" Label ":" Choices "=>" Generate_Statement_Body;
CaseGenerateAlt . Case_Genreate_Alternative ::=
                "when" Choices "=>" Generate_Statement_Body;

Case_Generate_Statement ::=
CaseGenerateStmt . Case_Generate_Statement ::=
                 Label ":" "case" Expression "generate"
                 [Case_Generate_Alternative] "end" "generate";
CaseGenerateStmtLbl . Case_Generate_Statement ::=
                    Label ":" "case" Expression "generate"
                    [Case_Generate_Alternative] "end" "generate" Label ;


CaseSimpleStmt . Case_Statement ::= "case" Expression "is" [Case_Statement_Alternative] "end" "case";
CaseQStmt . Case_Statement ::= "case" "?" Expression "is" [Case_Statement_Alternative] "end" "case" "?";
LabeledCaseStmt . Case_Statement ::= Label ":" "case" Expression "is" [Case_Statement_Alternative] "end" "case" Label ] ;
LabeledCaseQStmt . Case_Statement ::= Label ":" "case" "?" Expression "is" [Case_Statement_Alternative] "end" "case" "?" Label;

separator Case_Statement_Alternative "";
Case_Statement_Alternative ::= "when" [Choice] => Sequence_Of_Statements

Character_Literal ::= "'" Graphic_Character "'"

separator nonempty Choice "|";
ExpChoice . Choice ::= Simple_Expression;
RangeChoice . Choice ::= Discrete_Range;
NameChoice . Choice ::= Simple_Name;
OthersChoice . Choice ::= "others";

terminator Verification_Unit_Binding_Indication ";";

SimpleComConfig . Component_Configuration ::=
                "for" Component_Specification [Verification_Unit_Binding_Indication]
                "end" "for" ;
BindingComConfig . Component_Configuration ::=
                 "for" Component_Specification Binding_Indication ";"
                 [Verification_Unit_Binding_Indication] "end" "for" ;
BlockComConfig . Component_Configuration ::=
               "for" Component_Specification [Verification_Unit_Binding_Indication]
               Block_Configuration "end" "for" ;
BindingBlockComConfig . Component_Configuration ::=
                      "for" Component_Specification Binding_Indication ";"
                      [Verification_Unit_Binding_Indication] Block_Configuration
                      "end" "for" ;

Component_Declaration ::= "oomponent" Identifier "is" [ Local_Generic_Clause ] [ Local_Port_Clause ] "end" "component" [ Component_Simple_Name ] ;

Component_Declaration ::= "oomponent" Identifier [ Local_Generic_Clause ] [ Local_Port_Clause ] "end" "component" [ Component_Simple_Name ] ;

Component_Instantiation_Statement ::=
Instantiation_Label :
Instantiated_Unit
[ Generic_Map_Aspect ] [ Port_Map_Aspect ] ;

Component_Specification ::=
Instantiation_List : Component_Name

Composite_Type_Definition ::=
Array_Type_Definition
| Record_Type_Definition

Compound_Configuration_Specification ::=
"for" Component_Specification Binding_Indication ;
Verification_Unit_Binding_Indication ;
{ Verification_Unit_Binding_Indication ; } End For ;

ConcAssertStmt . Concurrent_Assertion_Statement ::= "postponed" Assertion ";"
ConcAssertStmtL . Concurrent_Assertion_Statement ::= Label ":" "postponed" Assertion ";"

ConcCondSigAssign . Concurrent_Conditional_Signal_Assignment ::= Target "<="                           Conditional_Waveforms ";"
ConcCondSigAssignD . Concurrent_Conditional_Signal_Assignment ::= Target "<="           Delay_Mechanism Conditional_Waveforms ";"
ConcCondSigAssignG . Concurrent_Conditional_Signal_Assignment ::= Target "<=" "guarded"                 Conditional_Waveforms ";"
ConcCondSigAssignGD . Concurrent_Conditional_Signal_Assignment ::= Target "<=" "guarded" Delay_Mechanism Conditional_Waveforms ";"

ConcProcCallStmt . Concurrent_Procedure_Call_Statement ::= Procedure_Call ";"
ConcProcCallStmtL . Concurrent_Procedure_Call_Statement ::=  Label ":"   Procedure_Call ";"
ConcProcCallStmtP . Concurrent_Procedure_Call_Statement ::=  "postponed"  Procedure_Call ";"
ConcProcCallStmtLP . Concurrent_Procedure_Call_Statement ::=  Label ":"   "postponed"  Procedure_Call ";"

ConcSelSigAssign . Concurrent_Selected_Signal_Assignment ::= "with" Expression "select"         Target "<="                                   Selected_Waveforms ";"
ConcSelSigAssignD . Concurrent_Selected_Signal_Assignment ::= "with" Expression "select"         Target "<="                Delay_Mechanism  Selected_Waveforms ";"
ConcSelSigAssignG . Concurrent_Selected_Signal_Assignment ::= "with" Expression "select"         Target "<="  "guarded"                      Selected_Waveforms ";"
ConcSelSigAssignGD . Concurrent_Selected_Signal_Assignment ::= "with" Expression "select"         Target "<="  "guarded"   Delay_Mechanism  Selected_Waveforms ";"
ConcSelSigAssignQ . Concurrent_Selected_Signal_Assignment ::= "with" Expression "select"  "?"  Target "<="                                   Selected_Waveforms ";"
ConcSelSigAssignQD . Concurrent_Selected_Signal_Assignment ::= "with" Expression "select"  "?"  Target "<="                Delay_Mechanism  Selected_Waveforms ";"
ConcSelSigAssignGD . Concurrent_Selected_Signal_Assignment ::= "with" Expression "select"  "?"  Target "<="  "guarded"                      Selected_Waveforms ";"
ConcSelSigAssignQGD . Concurrent_Selected_Signal_Assignment ::= "with" Expression "select"  "?"  Target "<="  "guarded"   Delay_Mechanism  Selected_Waveforms ";"

ConcSigAssignStmtS . Concurrent_Signal_Assignment_Statement ::=  Concurrent_Simple_Signal_Assignment;
ConcSigAssignStmtSL . Concurrent_Signal_Assignment_Statement ::=  Label ":"   Concurrent_Simple_Signal_Assignment;
ConcSigAssignStmtSP . Concurrent_Signal_Assignment_Statement ::=  "postponed"  Concurrent_Simple_Signal_Assignment;
ConcSigAssignStmtSPL . Concurrent_Signal_Assignment_Statement ::=  Label ":"   "postponed"  Concurrent_Simple_Signal_Assignment;

ConcSigAssignStmtC . Concurrent_Signal_Assignment_Statement ::=  Concurrent_Conditional_Signal_Assignment;
ConcSigAssignStmtCL . Concurrent_Signal_Assignment_Statement ::=  Label ":"   Concurrent_Conditional_Signal_Assignment;
ConcSigAssignStmtCP . Concurrent_Signal_Assignment_Statement ::=  "postponed"  Concurrent_Conditional_Signal_Assignment;
ConcSigAssignStmtCPL . Concurrent_Signal_Assignment_Statement ::=  Label ":"   "postponed"  Concurrent_Conditional_Signal_Assignment;

ConcSigAssignStmtSe . Concurrent_Signal_Assignment_Statement ::=   Concurrent_Selected_Signal_Assignment;
ConcSigAssignStmtSeL . Concurrent_Signal_Assignment_Statement ::=  Label ":"   Concurrent_Selected_Signal_Assignment;
ConcSigAssignStmtSeP . Concurrent_Signal_Assignment_Statement ::=  "postponed"  Concurrent_Selected_Signal_Assignment;
ConcSigAssignStmtSePL . Concurrent_Signal_Assignment_Statement ::=  Label ":"   "postponed"  Concurrent_Selected_Signal_Assignment;

Concurrent_Simple_Signal_Assignment ::=
Target <= [ Guarded ] [ Delay_Mechanism ] Waveform ;

ConcurrentStmtBlock . Concurrent_Statement ::= Block_Statement;
ConcurrentStmtProc . Concurrent_Statement ::= Process_Statement;
ConcurrentStmtCall . Concurrent_Statement ::= Concurrent_Procedure_Call_Statement;
ConcurrentStmtAssert . Concurrent_Statement ::= Concurrent_Assertion_Statement;
ConcurrentStmtAssign . Concurrent_Statement ::= Concurrent_Signal_Assignment_Statement;
ConcurrentStmtComp . Concurrent_Statement ::= Component_Instantiation_Statement;
ConcurrentStmtGen . Concurrent_Statement ::= Generate_Statement;
ConcurrentStmtPSL . Concurrent_Statement ::= Psl_Psl_Directive;

_ . Condition ::= Expression


Condition_Clause ::= "Until" Condition;

Condition_Operator ::= "??";

ConditionalExp . Conditional_Expressions ::= Expression "when" Condition [Conditional_Exp_Else];
ConditionalExpElse . Conditional_Expressions ::= Expression "when" Condition [Conditional_Exp_Else] "else" Expression;

separator Conditional_Exp_Else "";
_ . Conditional_Exp_Else ::= "else" Expression "when" Condition;

CondForceAssign . Conditional_Force_Assignment ::= Target "<=" "force" Conditional_Expressions ";"
CondForceAssign . Conditional_Force_Assignment ::= Target "<=" "force" Force_Mode Conditional_Expressions ";"

ConditionalSigAssignWave . Conditional_Signal_Assignment ::= Conditional_Waveform_Assignment;
ConditionalSigAssignForce . Conditional_Signal_Assignment ::= Conditional_Force_Assignment;

Conditional_Variable_Assignment ::= Target ":=" Conditional_Expressions ";"

CondWaveformAssign . Conditional_Waveform_Assignment ::= Target "<=" Conditional_Waveforms ;
CondWaveformAssignDelay . Conditional_Waveform_Assignment ::= Target "<=" Delay_Mechanism Conditional_Waveforms ;

CondWaveform . Conditional_Waveforms ::= Waveform "when" Condition [Conditional_Waveform_Temp] ;
CondWaveformElse . Conditional_Waveforms ::= Waveform "when" Condition [Conditional_Waveform_Temp] "else" Waveform;

separator Conditional_Waveform_Temp "";
_ . Conditional_Waveform_Temp ::= "else" Waveform "when" Condition;

ConfigDecl . Configuration_Declaration ::=
           "configuration" Identifier "of" Name "is" Configuration_Declarative_Part Configuration_Declaration_Temp Block_Configuration "end" ";";
ConfigDeclC . Configuration_Declaration ::=
           "configuration" Identifier "of" Name "is" Configuration_Declarative_Part Configuration_Declaration_Temp Block_Configuration "end" "configuration" ";";
ConfigDeclI . Configuration_Declaration ::=
           "configuration" Identifier "of" Name "is" Configuration_Declarative_Part Configuration_Declaration_Temp Block_Configuration "end" Simple_Name ";";
ConfigDeclCI . Configuration_Declaration ::=
           "configuration" Identifier "of" Name "is" Configuration_Declarative_Part Configuration_Declaration_Temp Block_Configuration "end" "configuration" Simple_Name ";";

terminator Verification_Unit_Binding_Indication ";";
_ . Configuration_Declaration_Temp ::= [Verification_Unit_Binding_Indication ";"];

ConfigDeclItemUse . Configuration_Declarative_Item ::= Use_Clause;
ConfigDeclItemAttr . Configuration_Declarative_Item ::= Attribute_Specification;
ConfigDeclItemGroup . Configuration_Declarative_Item ::= Group_Declaration;

separator Configuration_Declarative_Item "";
_ . Configuration_Declarative_Part ::= [Configuration_Declarative_Item];

ConfigItemBlock . Configuration_Item ::= Block_Configuration;
ConfigItemComp . Configuration_Item ::= Component_Configuration;

Configuration_Specification ::=
ConfigSpecSimple . Configuration_Specification ::= Simple_Configuration_Specification;
ConfigSpecCompound . Configuration_Specification ::= Compound_Configuration_Specification;

ConstDecl . Constant_Declaration ::= "constant" [Identifier] ":" Subtype_Indication ";";
ConstDeclInit . Constant_Declaration ::= "constant" [Identifier] ":" Subtype_Indication ":=" Expression ";";

ConstrArrDef . Constrained_Array_Definition ::= "array" Index_Constraint "of" Subtype_Indication;

ConstraintRange . Constraint ::= Range_Constraint;
ConstraintArray . Constraint ::= Array_Constraint;
ConstraintRecord . Constraint ::= Record_Constraint;

separator Context_Item "";
_ . Context_Clause ::= [Context_Item];

Context_Declaration ::=
Context Identifier Is
Context_Clause
End [ Context ] [ Context_Simple_Name ] ;

ContextItemLib . Context_Item ::= Library_Clause;
ContextItemUse . Context_Item ::= Use_Clause;
ContextItemCon . Context_Item ::= Context_Reference;

separator nonempty Selected_Name ",";
ContextRef . Context_Reference ::= Context [Selected_Name] ";";

token Decimal_Literal "("'d' 'u' 'm' 'm' 'y');

DelayMechanismTrans . Delay_Mechanism ::= "transport";
DelayMechanismRej . Delay_Mechanism ::= "reject" Expression "inertial";
DelayMechanismInertial . Delay_Mechanism ::= "inertial";

separator nonempty Design_Unit "";
_ . Design_File ::= [Design_Unit];

DesignUnit . Design_Unit ::= Context_Clause Library_Unit;

DesignatorId . Designator ::= Identifier;
DesignatorOp . Designator ::= Operator_Symbol;

DirectionTo . Direction ::= "to";
DirectionDownto . Direction ::= "downto";

DisconnectSpec . Disconnection_Specification ::= "disconnect" Guarded_Signal_Specification "after" Expression ";";

DiscreteRangeSub . Discrete_Range ::= Subtype_Indication;
DiscreteRangeRange . Discrete_Range ::= Range;

ElementAssocChoice . Element_Association ::= [Choice] "=>" Expression;
ElementAssoc . Element_Association ::=  Expression;

ElementConstraint . Element_Constraint ::= Array_Constraint;
ElementConstraint . Element_Constraint ::= Record_Constraint;

ElementDecl . Element_Declaration ::= [Identifier] ":" Element_Subtype_Definition ";";

ElementResolutionArray . Element_Resolution ::= Array_Element_Resolution;
ElementResolutionRecord . Element_Resolution ::= Record_Resolution;

_ . Element_Subtype_Definition ::= Subtype_Indication;

EntityAspect . Entity_Aspect ::= "entity" Name;
EntityAspect . Entity_Aspect ::= "entity" Name "(" Architecture_Identifier ")";
EntityAspect . Entity_Aspect ::= "configuration" Name;
EntityAspect . Entity_Aspect ::= "open";

-- TODO: This probably is incorrect!!! FM. MA
EntityClassEnt . Entity_Class ::= Entity;
EntityClassArch . Entity_Class ::= Architecture;
EntityClassConf . Entity_Class ::= Configuration;
EntityClassProc . Entity_Class ::= Procedure;
EntityClassFunc . Entity_Class ::= Function;
EntityClassPack . Entity_Class ::= Package;
EntityClassType . Entity_Class ::= Type;
EntityClassSubt . Entity_Class ::= Subtype;
EntityClassConst . Entity_Class ::= Constant;
EntityClassSig . Entity_Class ::= Signal;
EntityClassVar . Entity_Class ::= Variable;
EntityClassComp . Entity_Class ::= Component;
EntityClassLab . Entity_Class ::= Label;
EntityClassLiteral . Entity_Class ::= Literal;
EntityClassUnits . Entity_Class ::= Units;
EntityClassGroup . Entity_Class ::= Group;
EntityClassFile . Entity_Class ::= File;
EntityClassProp . Entity_Class ::= Property;
EntityClassSequence . Entity_Class ::= Sequence;

EntityClassEntryBox . Entity_Class_Entry ::= Entity_Class "<>";
EntityClassEntry . Entity_Class_Entry ::= Entity_Class;

separator Entity_Class_Entry ",";
Entity_Class_Entry_List ::= [Entity_Class_Entry];

EntityDecl . Entity_Declaration ::= "entity" Identifier "is" Entity_Header Entity_Declarative_Part "end"  ";";
EntityDeclLabel . Entity_Declaration ::= "entity" Identifier "is" Entity_Header Entity_Declarative_Part "end"  Simple_Name  ";";
EntityDeclE . Entity_Declaration ::= "entity" Identifier "is" Entity_Header Entity_Declarative_Part "end"  "entity"   ";";
EntityDeclELabel . Entity_Declaration ::= "entity" Identifier "is" Entity_Header Entity_Declarative_Part "end"  "entity"   Simple_Name  ";";
EntityDeclS . Entity_Declaration ::= "entity" Identifier "is" Entity_Header Entity_Declarative_Part  "begin" Entity_Statement_Part  "end" ";";
EntityDeclSLabel . Entity_Declaration ::= "entity" Identifier "is" Entity_Header Entity_Declarative_Part  "begin" Entity_Statement_Part  "end"  Simple_Name  ";";
EntityDeclSE . Entity_Declaration ::= "entity" Identifier "is" Entity_Header Entity_Declarative_Part  "begin" Entity_Statement_Part  "end"  "entity"   ";";
EntityDeclSELabel . Entity_Declaration ::= "entity" Identifier "is" Entity_Header Entity_Declarative_Part  "begin" Entity_Statement_Part  "end"  "entity"   Simple_Name  ";";

EntityDeclItermSubprogDecl . Entity_Declarative_Iterm ::= Subprogram_Declaration;
EntityDeclItermSubprogBody . Entity_Declarative_Iterm ::= Subprogram_Body;
EntityDeclItermSubprogInst . Entity_Declarative_Iterm ::= Subprogram_Instantiation_Declaration;
EntityDeclItermPackageDecl . Entity_Declarative_Iterm ::= Package_Declaration;
EntityDeclItermPackageBody . Entity_Declarative_Iterm ::= Package_Body;
EntityDeclItermPackageInst . Entity_Declarative_Iterm ::= Package_Instantiation_Declaration;
EntityDeclItermTypeDecl . Entity_Declarative_Iterm ::= Type_Declaration;
EntityDeclItermSubtypeDecl . Entity_Declarative_Iterm ::= Subtype_Declaration;
EntityDeclItermConstDecl . Entity_Declarative_Iterm ::= Constant_Declaration;
EntityDeclItermSigDecl . Entity_Declarative_Iterm ::= Signal_Declaration;
EntityDeclItermShared . Entity_Declarative_Iterm ::= Shared_Variable_Declaration;
EntityDeclItermFile . Entity_Declarative_Iterm ::= File_Declaration;
EntityDeclItermAlias . Entity_Declarative_Iterm ::= Alias_Declaration;
EntityDeclItermAttrDecl . Entity_Declarative_Iterm ::= Attribute_Declaration;
EntityDeclItermAttrSpec . Entity_Declarative_Iterm ::= Attribute_Specification;
EntityDeclItermDisconn . Entity_Declarative_Iterm ::= Disconnection_Specification;
EntityDeclItermUse . Entity_Declarative_Iterm ::= Use_Clause;
EntityDeclItermGroupTemp . Entity_Declarative_Iterm ::= Group_Template_Declaration;
EntityDeclItermGroup . Entity_Declarative_Iterm ::= Group_Declaration;
EntityDeclItermPSLProp . Entity_Declarative_Iterm ::= Psl_Property_Declaration;
EntityDeclItermPSLSeq . Entity_Declarative_Iterm ::= Psl_Sequence_Declaration;
EntityDeclItermPSLClock . Entity_Declarative_Iterm ::= Psl_Clock_Declaration;


Entity_Declarative_Part ::= { Entity_Declarative_Item };

EntityDesignator . Entity_Designator ::= Entity_Tag;
EntityDesignator . Entity_Designator ::= Entity_Tag Signature;

EntityHeader . Entity_Header ::= ;
EntityHeaderP . Entity_Header ::= Formal_Port_Clause;
EntityHeaderG . Entity_Header ::= Formal_Generic_Clause ;
EntityHeaderGP . Entity_Header ::= Formal_Generic_Clause Formal_Port_Clause;

separator nonempty Entity_Designator ",";

EntityNameList . Entity_Name_List ::= [Entity_Designator];
EntityNameList . Entity_Name_List ::= "others";
EntityNameList . Entity_Name_List ::= "all";

EntitySpec . Entity_Specification ::= Entity_Name_List ":" Entity_Class;

EntityStmtConc . Entity_Statement ::= Concurrent_Assertion_Statement;
EntityStmtPassiveConc . Entity_Statement ::= Passive_Concurrent_Procedure_Call_Statement;
EntityStmtPassiveProc . Entity_Statement ::= Passive_Process_Statement;
EntityStmtPSL . Entity_Statement ::= Psl_Psl_Directive;

terminator Entity_Statement "";
_ . Entity_Statement_Part ::= [Entity_Statement];

Entity_Tag ::=
Simple_Name | Character_Literal | Operator_Symbol

Enumeration_Literal ::=
Identifier | Character_Literal

Enumeration_Type_Definition ::=
( Enumeration_Literal { , Enumeration_Literal } ")"

Exit_Statement ::=
[ Label : ] Exit [ Loop_Label ] [ When Condition ] ;

Exponent ::=
E [ + ] Integer | E – Integer

ExpCondition . Expression ::= Condition_Operator Primary;
ExpLogical . Expression ::= Logical_Expression;

ExtDigitDig . Extended_Digit ::= Digit;
ExtDigitLetter . Extended_Digit ::= Letter;


ExternalNameConst . External_Name ::= External_Constant_Name;
ExternalNameSig . External_Name ::= External_Signal_Name;
ExternalNameVar . External_Name ::= External_Variable_Name;

ExtConstName . External_Constant_Name ::= "<<" Constant External_Pathname ":" Subtype_Indication ">>";

ExtSigName . External_Signal_Name ::= "<<" Signal External_Pathname ":" Subtype_Indication ">>";

ExtVarName . External_Variable_Name ::= "<<" Variable External_Pathname ":" Subtype_Indication ">>";

ExternalPathnamePackage . External_Pathname ::= Package_Pathname;
ExternalPathnameAbsolute . External_Pathname ::= Absolute_Pathname;
ExternalPathnameRelative . External_Pathname ::= Relative_Pathname;

FactorPow . Factor ::= Primary "**" Primary;
_ . Factor ::= Primary ;
FactorAbs . Factor ::= "abs" Primary;
FactorNot . Factor ::= "not" Primary;
FactorLog . Factor ::= Logical_Operator Primary;

FileDecl . File_Declaration ::= "file" [Identifier] ":" Subtype_Indication;
FileDeclOpeninfo . File_Declaration ::= "file" [Identifier] ":" Subtype_Indication File_Open_Information;

_ . File_Logical_Name ::= Expression;

FileOpenInfo . File_Open_Information ::= "is" File_Logical_Name;
FileOpenInfoOpen . File_Open_Information ::= "open" File_Open_Kind_Expression "is" File_Logical_Name;

FileTypDef . File_Type_Definition ::= "file" "of" Type_Mark;

_ . Floating_Type_Definition ::= Range_Constraint;

ForGenStmt . For_Generate_Statement ::= Label ":" "for" Generate_Parameter_Specification "generate" Generate_Statement_Body "end" "generate";
ForGenStmt . For_Generate_Statement ::= Label ":" "for" Generate_Parameter_Specification "generate" Generate_Statement_Body "end" "generate" Generate_Label;

ForceModeIn . Force_Mode ::= "In";
ForceModeOut . Force_Mode ::= "Out";

FormalDesignatorGeneric . Formal_Designator ::= Generic_Name;
FormalDesignatorPort . Formal_Designator ::= Port_Name;
FormalDesignatorParam . Formal_Designator ::= Parameter_Name;

_ . Formal_Parameter_List ::= Parameter_Interface_List;

FormalPartFd . Formal_Part ::= Formal_Designator;
FormalPartFunc . Formal_Part ::= Function_Name "(" Formal_Designator ")";
FormalPartType . Formal_Part ::= Type_Mark "(" Formal_Designator ")";

FullTypeDecl . Full_Type_Declaration ::= "type" Identifier "is" Type_Definition ";";

FuncCallNyad . Function_Call ::= Function_Name;
FuncCallPolyad . Function_Call ::= Function_Name "(" Actual_Parameter_Part ")"

Function_Specification ::=
[ Pure | Impure ] Function Designator
Subprogram_Header
[ [ Parameter ] "(" Formal_Parameter_List ")" ] Return Type_Mark

Generate_Specification ::=
Static_Discrete_Range
| Static_Expression
| Alternative_Label

Generate_Statement ::=
For_Generate_Statement
| If_Generate_Statement
| Case_Generate_Statement

Generate_Statement_Body ::=
[ Block_Declarative_Part
Begin ]
{ Concurrent_Statement }
[ End [ Alternative_Label ] ; ]

Generic_Clause ::=
Generic "(" Generic_List ")" ;

Generic_List ::=
Generic_Interface_List

Generic_Map_Aspect ::=
Generic Map "(" Generic_Association_List ")"

Graphic_Character ::=
Basic_Graphic_Character | Lower_Case_Letter | Other_Special_Character

Group_Constituent ::=
Name | Character_Literal

Group_Constituent_List ::=
Group_Constituent { , Group_Constituent }

Group_Declaration ::=
Group Identifier : Group_Template_Name "(" Group_Constituent_List ")" ;

Group_Template_Declaration ::= Group Identifier "is" "(" Entity_Class_Entry_List ")" ;

Guarded_Signal_Specification ::= Guarded_Signal_List ":" Type_Mark;

Identifier ::=
Basic_Identifier | Extended_Identifier

-- Basic_Identifier ::=
-- Letter { [ Underline ] Letter_Or_Digit }
-- Extended_Identifier ::=
-- \ Graphic_Character { Graphic_Character } \

token Basic_Identifier "("'d');
token Extended_Identifier "("'d');

separator Identifier ",";

If_Generate_Statement ::= Label ":" "if" Condition "generate" Generate_Statement_Body [Elsif_Generate_Parts] [ ElseGenPart ] "end" "Generate" [ Generate_Label ] ";"
If_Generate_Statement ::= Label ":" "if" [ Alternative_Label ":" ] Condition "generate" Generate_Statement_Body [Elsif_Generate_Parts] [ ElseGenPart ] "end" "Generate" [ Generate_Label ] ";"
If_Generate_Statement ::= Label ":" "if" [ Alternative_Label ":" ] Condition "generate" Generate_Statement_Body [Elsif_Generate_Parts] [ ElseGenPart ] "end" "Generate" [ Generate_Label ] ";"
If_Generate_Statement ::= Label ":" "if" [ Alternative_Label ":" ] Condition "generate" Generate_Statement_Body [Elsif_Generate_Parts] [ ElseGenPart ] "end" "Generate" [ Generate_Label ] ";"

separator Elsif_Generate_Parts "";
ElsifGenPartsLab . Elsif_Generate_Parts ::= "elsif" Alternative_Label ":" Condition "generate" Generate_Statement_Body;
ElsifGenParts . Elsif_Generate_Parts ::= "elsif" Condition "generate" Generate_Statement_Body;

ElseGenPartLabel . Else_Gen_Part ::= "else" Alternative_Label ":" Generate Generate_Statement_Body;
ElseGenPart . Else_Gen_Part ::= "else" Generate Generate_Statement_Body;

IfStatement . If_Statement ::= "if" Condition "then" [Sequential_Statement] [Elsif_Parts] "end" "if" ";"
IfStatementL . If_Statement ::= [ Label ":" ] "if" Condition "then" [Sequential_Statement] [Elsif_Parts] "end" "if" [ Label ] ";"
IfStatementE . If_Statement ::= "if" Condition "then" [Sequential_Statement] [Elsif_Parts] "else" [Sequential_Statement] "end" "if" ";"
IfStatementLE . If_Statement ::= [ Label ":" ] "if" Condition "then" [Sequential_Statement] [Elsif_Parts] "else" [Sequential_Statement] "end" "if" [ Label ] ";"

terminator Elsif_Parts "";
ElsifParts . Elsif_Parts ::= "elsif" Condition "then" [Sequential_Statement]

IncompleteTypeDef . Incomplete_Type_Declaration ::= Type Identifier ";";

separator nonempty Discrete_Range ",";
IndexConstraint . Index_Constraint ::= "(" [Discrete_Range] ")";

IndexSubtDef . Index_Subtype_Definition ::= Type_Mark "range" "<>";

separator nonempty Expression ",";
Indexed_Name ::= Prefix "(" [Expression] ")";

Instantiated_Unit ::=
[ Component ] Component_Name
| Entity Entity_Name [ "(" Architecture_Identifier ")" ]
| Configuration Configuration_Name

Instantiation_List ::=
Instantiation_Label { , Instantiation_Label }
| Others
| All

Integer ::=
Digit { [ Underline ] Digit }

Integer_Type_Definition ::=
Range_Constraint

Interface_Constant_Declaration ::=
[ Constant ] [Identifier] : [ In ] Subtype_Indication [ := Static_Expression ]

Interface_Declaration ::=
Interface_Object_Declaration
| Interface_Type_Declaration
| Interface_Subprogram_Declaration
| Interface_Package_Declaration

Interface_Element ::=
Interface_Declaration

Interface_File_Declaration ::=
File [Identifier] : Subtype_Indication

Interface_Function_Specification ::=
[ Pure | Impure ] Function Designator
[ [ Parameter ] "(" Formal_Parameter_List ")" ] Return Type_Mark

Interface_Incomplete_Type_Declaration ::=
Type Identifier

Interface_List ::=
Interface_Element { ; Interface_Element }

Interface_Object_Declaration ::=
Interface_Constant_Declaration
| Interface_Signal_Declaration
| Interface_Variable_Declaration
| Interface_File_Declaration

Interface_Package_Declaration ::=
Package Identifier Is
New Uninstantiated_Package_Name Interface_Package_Generic_Map_Aspect

Interface_Package_Generic_Map_Aspect ::=
Generic_Map_Aspect
| Generic Map "(" <> ")"
| Generic Map "(" Default ")"

Interface_Procedure_Specification ::=
Procedure Designator
[ [ Parameter ] "(" Formal_Parameter_List ")" ]

Interface_Signal_Declaration ::=
[ Signal ] [Identifier] : [ Mode ] Subtype_Indication [ Bus ] [ := Static_Expression ]

Interface_Subprogram_Declaration ::=
Interface_Subprogram_Specification [ Is Interface_Subprogram_Default ]

Interface_Subprogram_Default ::=
Subprogram_Name | <>

Interface_Subprogram_Specification ::=
Interface_Procedure_Specification | Interface_Function_Specification

Interface_Type_Declaration ::=
Interface_Incomplete_Type_Declaration

Interface_Variable_Declaration ::=
[ Variable ] [Identifier] : [ Mode ] Subtype_Indication [ := Static_Expression ]

Iteration_Scheme ::=
While Condition
| For Loop_Parameter_Specification

_ . Label ::= Identifier

Letter ::=
Upper_Case_Letter | Lower_Case_Letter

Letter_Or_Digit ::=
Letter | Digit

Library_Clause ::=
Library Logical_Name_List ;

Library_Unit ::=
Primary_Unit
| Secondary_Unit

Literal ::=
Numeric_Literal
| Enumeration_Literal
| String_Literal
| Bit_String_Literal
| Null

Logical_Expression ::=
Relation { And Relation }
| Relation { Or Relation }
| Relation { Xor Relation }
| Relation [ Nand Relation ]
| Relation [ Nor Relation ]
| Relation { Xnor Relation }

Logical_Name ::=
Identifier

Logical_Name_List ::=
Logical_Name { , Logical_Name }

Logical_Operator ::=
And | Or | Nand | Nor | Xor | Xnor

Loop_Statement ::=
[ Loop_Label : ]
[ Iteration_Scheme ] Loop Sequence_Of_Statements
End Loop [ Loop_Label ] ;

Miscellaneous_Operator ::=
** | Abs | Not

Mode ::=
In | Out | Inout | Buffer | Linkage

Multiplying_Operator ::=
* | / | Mod | Rem

Name ::=
Simple_Name
| Operator_Symbol
| Character_Literal
| Selected_Name
| Indexed_Name
| Slice_Name
| Attribute_Name
| External_Name

Next_Statement ::=
[ Label : ] Next [ Loop_Label ] [ When Condition ] ;

Null_Statement ::=
[ Label : ] Null ;

Numeric_Literal ::=
Abstract_Literal | Physical_Literal

Object_Declaration ::=
Constant_Declaration
| Signal_Declaration
| Variable_Declaration
| File_Declaration

Operator_Symbol ::=
String_Literal

Package_Body ::=
Package Body Package_Simple_Name Is
Package_Body_Declarative_Part
End [ Package Body ] [ Package_Simple_Name ] ;

Package_Body_Declarative_Item ::=
Subprogram_Declaration
| Subprogram_Body
| Subprogram_Instantiation_Declaration
| Package_Declaration
| Package_Body
| Package_Instantiation_Declaration
| Type_Declaration
| Subtype_Declaration
| Constant_Declaration
| Variable_Declaration
| File_Declaration
| Alias_Declaration
| Attribute_Declaration
| Attribute_Specification
| Use_Clause
| Group_Template_Declaration
| Group_Declaration

Package_Body_Declarative_Part ::=
{ Package_Body_Declarative_Item }

Package_Declaration ::=
Package Identifier Is
Package_Header
Package_Declarative_Part
End [ Package ] [ Package_Simple_Name ] ;

Package_Declarative_Item ::=
Subprogram_Declaration
| Subprogram_Instantiation_Declaration
| Package_Declaration
| Package_Instantiation_Declaration
| Type_Declaration
| Subtype_Declaration
| Constant_Declaration
| Signal_Declaration
| Variable_Declaration
| File_Declaration
| Alias_Declaration
| Component_Declaration
| Attribute_Declaration
| Attribute_Specification
| Disconnection_Specification
| Use_Clause
| Group_Template_Declaration
| Group_Declaration
| Psl_Property_Declaration
| Psl_Sequence_Declaration

Package_Declarative_Part ::=
{ Package_Declarative_Item }

Package_Header ::=
[ Generic_Clause
[ Generic_Map_Aspect ; ] ]

Package_Instantiation_Declaration ::=
Package Identifier Is New Uninstantiated_Package_Name
[ Generic_Map_Aspect ] ;

Package_Pathname ::=
@ Library_Logical_Name . { Package_Simple_Name . } Simple_Name

Parameter_Specification ::=
Identifier In Discrete_Range

Partial_Pathname ::= { Pathname_Element "." } Simple_Name

Pathname_Element ::=
  Simple_Name
| Component_Instantiation_Label
| Block_Label
| Generate_Statement_Label [ "(" Static_Expression ")" ]
| Package_Simple_Name

PhysicalLiteral . Physical_Literal ::= Unit_Name
PhysicalLiteral . Physical_Literal ::= Abstract_Literal Unit_Name

Physical_Type_Definition ::=
Range_Constraint
Units
Primary_Unit_Declaration
{ Secondary_Unit_Declaration }
End Units [ Physical_Type_Simple_Name ]

Port_Clause ::=
Port "(" Port_List ")" ;

Port_List ::=
Port_Interface_List

Port_Map_Aspect ::=
Port Map "(" Port_Association_List ")"

Prefix ::=
Name | Function_Call

Primary ::=
Name
| Literal
| Aggregate
| Function_Call
| Qualified_Expression | Type_Conversion
| Allocator
| "(" Expression ")"

Primary_Unit ::=
Entity_Declaration
| Configuration_Declaration
| Package_Declaration
| Package_Instantiation_Declaration | Context_Declaration
| Psl_Verification_Unit

Primary_Unit_Declaration ::=
Identifier ;

Procedure_Call ::=
Procedure_Name [ "(" Actual_Parameter_Part ")" ]

Procedure_Call_Statement ::=
[ Label : ] Procedure_Call ;

Procedure_Specification ::=
Procedure Designator
Subprogram_Header
[ [ Parameter ] "(" Formal_Parameter_List ")" ]

Process_Declarative_Item ::=
Subprogram_Declaration
| Subprogram_Body
| Subprogram_Instantiation_Declaration
| Package_Declaration
| Package_Body
| Package Instantiation_Declaration
| Type_Declaration
| Subtype_Declaration
| Constant_Declaration
| Variable_Declaration
| File_Declaration
| Alias_Declaration
| Attribute_Declaration
| Attribute_Specification
| Use_Clause
| Group_Template_Declaration
| Group_Declaration

Process_Declarative_Part ::=
{ Process_Declarative_Item }

Process_Sensitivity_List ::=
All | Sensitivity_List

Process_Statement ::=
[ Process_Label : ]
[ Postponed ] Process [ "(" Process_Sensitivity_List ")" ] [ Is ] Process_Declarative_Part
Begin
Process_Statement_Part
End [ Postponed ] Process [ Process_Label ] ;

Process_Statement_Part ::=
{ Sequential_Statement }

Protected_Type_Body ::=
Protected Body
Protected_Type_Body_Declarative_Part
End Protected Body [ Protected_Type_Simple Name ]

Protected_Type_Body_Declarative_Item ::=
Subprogram_Declaration
| Subprogram_Body
| Subprogram_Instantiation_Declaration
| Package_Declaration
| Package_Body
| Package_Instantiation_Declaration
| Type_Declaration
| Subtype_Declaration
| Constant_Declaration
| Variable_Declaration
| File_Declaration
| Alias_Declaration
| Attribute_Declaration
| Attribute_Specification
| Use_Clause
| Group_Template_Declaration
| Group_Declaration

Protected_Type_Body_Declarative_Part ::=
{ Protected_Type_Body_Declarative_Item }

Protected_Type_Declaration ::=
Protected
Protected_Type_Declarative_Part
End Protected [ Protected_Type_Simple_Name ]

Protected_Type_Declarative_Item ::=
Subprogram_Declaration
| Subprogram_Instantiation_Declaration | Attribute_Specification
| Use_Clause

Protected_Type_Declarative_Part ::=
{ Protected_Type_Declarative_Item }

Protected_Type_Definition ::=
Protected_Type_Declaration
| Protected_Type_Body

Qualified_Expression ::=
Type_Mark ' "(" Expression ")"
| Type_Mark ' Aggregate

Range ::=
Range_Attribute_Na


Range_Constraint ::=
Range Range

Record_Constraint ::=
( Record_Element_Constraint { , Record_Element_Constraint } ")"

Record_Element_Constraint ::=
Record_Element_Simple_Name Element_Constraint

Record_Element_Resolution ::=
Record_Element_Simple_Name Resolution_Indication

Record_Resolution ::=
Record_Element_Resolution { , Record_Element_Resolution }

Record_Type_Definition ::=
Record
Element_Declaration
{ Element_Declaration }
End Record [ Record_Type_Simple_Name ]

Relation ::=
Shift_Expression [ Relational_Operator Shift_Expression ]

Relational_Operator ::=
= | /= | < | <= | > | >= | ?= | ?/= | ?< | ?<= | ?> | ?>=

Relative_Pathname ::=
{ ^ . } Partial_Pathname

Report_Statement ::=
[ Label : ]
Report Expression
[ Severity Expression ] ;

Resolution_Indication ::=
Resolution_Function_Name
| "(" Element_Resolution ")"

Return_Statement ::=
[ Label : ] Return [ Expression ] ;

Scalar_Type_Definition ::=
Enumeration_Type_Definition
| Integer_Type_Definition
| Floating_Type_Definition
| Physical_Type_Definition

Secondary_Unit ::=
Architecture_Body
| Package_Body

Secondary_Unit_Declaration ::=
Identifier = Physical_Literal ;

Selected_Expressions ::=
{ Expression When Choices , }
Expression When Choices

Selected_Force_Assignment ::=
With Expression Select [ ? ]
Target <= Force [ Force_Mode ] Selected_Expressions ;

Selected_Name ::=
Prefix . Suffix

Selected_Signal_Assignment ::=
Selected_Waveform_Assignment
| Selected_Force_Assignment

Selected_Variable_Assignment ::=
With Expression Select [ ? ]
Target := Selected_Expressions ;

Selected_Waveform_Assignment ::=
With Expression Select [ ? ]
Target <= [ Delay_Mechanism ] Selected_Waveforms ;

Selected_Waveforms ::=
{ Waveform When Choices , } Waveform When Choices

-- TODO: MARK here continue

_ . Sensitivity_Clause ::= "on" Sensitivity_List;

separator nonempty Signal_Name ",";
Sensitivity_List ::= [Signal_Name];

terminator Sequential_Statement "";
Sequence_Of_Statements ::= [Sequential_Statement];

SeqStmtWait . Sequential_Statement ::= Wait_Statement;
SeqStmtAssert . Sequential_Statement ::= Assertion_Statement;
SeqStmtReport . Sequential_Statement ::= Report_Statement;
SeqStmtSigass . Sequential_Statement ::= Signal_Assignment_Statement;
SeqStmtVarass . Sequential_Statement ::= Variable_Assignment_Statement;
SeqStmtProc . Sequential_Statement ::= Procedure_Call_Statement;
SeqStmtIf . Sequential_Statement ::= If_Statement;
SeqStmtCase . Sequential_Statement ::= Case_Statement;
SeqStmtLoop . Sequential_Statement ::= Loop_Statement;
SeqStmtNext . Sequential_Statement ::= Next_Statement;
SeqStmtExit . Sequential_Statement ::= Exit_Statement;
SeqStmtRet . Sequential_Statement ::= Return_Statement;
SeqStmtNull . Sequential_Statement ::= Null_Statement;

SimpleExprU . Shift_Expression ::= Simple_Expression;
SimpleExprB . Shift_Expression ::= Simple_Expression Shift_Operator Simple_Expression;

-- TODO: Sll | Srl | Sla | Sra | Rol | Ror
token Shift_Operator "("'d');

token Sign "("'+' | '-');

Signal_Assignment_Statement ::=
[ Label : ] Simple_Signal_Assignment
| [ Label : ] Conditional_Signal_Assignment
| [ Label : ] Selected_Signal_Assignment

Signal_Declaration ::=
Signal [Identifier] : Subtype_Indication [ Signal_Kind ] [ := Expression ] ;

SigKindReg . Signal_Kind ::= Register;
SigKindBus . Signal_Kind ::= Bus

separator nonempty Signal_Name ",";
SigListNames . Signal_List ::= [Signal_Name] ";";
SigListOthers . Signal_List ::= "others";
SigListAll . Signal_List ::= "all";

Signature ::=
[ [ Type_Mark { , Type_Mark } ] [ Return Type_Mark ] ]

Simple_Configuration_Specification ::=
For Component_Specification Binding_Indication ; [ End For ; ]

_ . SExpTem ::= Adding_Operator Term;
terminator SExpTerm "";
Simple_Expression ::= Sign Term [SExpTerm];
Simple_Expression ::= Term [SExpTerm];

SimpleForceAssign . Simple_Force_Assignment ::= Target "<=" "force" Expression ";";
SimpleForceAssignFm . Simple_Force_Assignment ::= Target "<=" "force" Force_Mode Expression ";";

_ . Simple_Name ::= Identifier;

SimpleReleaseAssign . Simple_Release_Assignment ::= Target "<=" Release ";"
SimpleReleaseAssign . Simple_Release_Assignment ::= Target "<=" Release Force_Mode ";"

SimpleSigAssignWave . Simple_Signal_Assignment ::= Simple_Waveform_Assignment;
SimpleSigAssignForce . Simple_Signal_Assignment ::= Simple_Force_Assignment;
SimpleSigAssignRelease . Simple_Signal_Assignment ::= Simple_Release_Assignment;

SimpleWavAssignD . Simple_Waveform_Assignment ::= Target "<=" Delay_Mechanism Waveform ;
SimpleWavAssign  . Simple_Waveform_Assignment ::= Target "<=" Waveform ;

SimpleVarAssign . Simple_Variable_Assignment ::= Target ":=" Expression ";";

SliceName . Slice_Name ::= Prefix "(" Discrete_Range ")";

-- TODO: Maybe token?
String_Literal ::= " { Graphic_Character } "

SubprogBody . Subprogram_Body ::= Subprogram_Specification "is" Subprogram_Declarative_Part "begin" Subprogram_Statement_Part "end"                           ;
SubprogBodyD . Subprogram_Body ::= Subprogram_Specification "is" Subprogram_Declarative_Part "begin" Subprogram_Statement_Part "end"                 Designator;
SubprogBodyS . Subprogram_Body ::= Subprogram_Specification "is" Subprogram_Declarative_Part "begin" Subprogram_Statement_Part "end" Subprogram_Kind           ;
SubprogBodySD . Subprogram_Body ::= Subprogram_Specification "is" Subprogram_Declarative_Part "begin" Subprogram_Statement_Part "end" Subprogram_Kind Designator;

_ . Subprogram_Declaration ::= Subprogram_Specification ";";

SubprogramDeclItem . Subprogram_Declarative_Item ::= Subprogram_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Subprogram_Body;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Subprogram_Instantiation_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Package_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Package_Body;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Package_Instantiation_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Type_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Subtype_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Constant_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Variable_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= File_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Alias_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Attribute_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Attribute_Specification;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Use_Clause;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Group_Template_Declaration;
SubprogramDeclItem . Subprogram_Declarative_Item ::= Group_Declaration;

Subprogram_Declarative_Part ::=
{ Subprogram_Declarative_Item }

Subprogram_Header ::=
[ Generic "(" Generic_List ")" [ Generic_Map_Aspect ] ]

Subprogram_Instantiation_Declaration ::=
Subprogram_Kind Identifier Is New Uninstantiated_Subprogram_Name [ Signature ] [ Generic_Map_Aspect ] ;

SubprogramKindProc . Subprogram_Kind ::= Procedure;
SubprogramKindFunc . Subprogram_Kind ::= Function

Subprogram_Specification ::=
SubprogramSpecProc . Procedure_Specification;
SubprogramSpecFunc . Function_Specification;

terminator Sequential_Statement "";
SubprogStmtPart . Subprogram_Statement_Part ::= [Sequential_Statement];

SubtypeDecl . Subtype_Declaration ::= "subtype" Identifier "is" Subtype_Indication;

SubtypeIndication   . Subtype_Indication ::=                       Type_Mark           ;
SubtypeIndicationC  . Subtype_Indication ::=                       Type_Mark Constraint;
SubtypeIndicationR  . Subtype_Indication ::= Resolution_Indication Type_Mark           ;
SubtypeIndicationRC . Subtype_Indication ::= Resolution_Indication Type_Mark Constraint;

SuffixName . Suffix ::= Simple_Name;
SuffixChar . Suffix ::= Character_Literal;
SuffixOp   . Suffix ::= Operator_Symbol;
SuffixAll  . Suffix ::= "all";

TargetName . Target ::= Name;
TargetAggr . Target ::= Aggregate;

Term ::= Factor { Multiplying_Operator Factor };

TimeoutClause . Timeout_Clause ::= "for" Time_Expression;

terminator Graphic_Character "";
ToolDir . Tool_Directive ::= "`" Identifier [Graphic_Character];

TypeConv . Type_Conversion ::= Type_Mark "(" Expression ")";

Type_Declaration ::= Full_Type_Declaration;
Type_Declaration ::= Incomplete_Type_Declaration;

TypeDefinitionScal . Type_Definition ::= Scalar_Type_Definition;
TypeDefinitionComp . Type_Definition ::= Composite_Type_Definition;
TypeDefinitionAcce . Type_Definition ::= Access_Type_Definition;
TypeDefinitionFile . Type_Definition ::= File_Type_Definition;
TypeDefinitionProt . Type_Definition ::= Protected_Type_Definition;

TypeMarkType . Type_Mark ::= Type_Name;
TypeMarkSubtype . Type_Mark ::= Subtype_Name;

separator nonempty Index_Subtype_Definition ",";
UnboundArrDef . Unbounded_Array_Definition ::= "array" "(" [Index_Subtype_Definition] ")" "of" Element_Subtype_Indication;

separator nonempty Selected_Name ",";
UseClause . Use_Clause ::= "use" [Selected_Name];

VarAssignStmtSimpL . Variable_Assignment_Statement ::= Label ":" Simple_Variable_Assignment;
VarAssignStmtSimp  . Variable_Assignment_Statement ::=           Simple_Variable_Assignment;
VarAssignStmtCondL . Variable_Assignment_Statement ::= Label ":" Conditional_Variable_Assignment;
VarAssignStmtCond  . Variable_Assignment_Statement ::=           Conditional_Variable_Assignment;
VarAssignStmtSeleL . Variable_Assignment_Statement ::= Label ":" Selected_Variable_Assignment;
VarAssignStmtSele  . Variable_Assignment_Statement ::=           Selected_Variable_Assignment;

VariableDecl    . Variable_Declaration ::=            Variable              ":" Subtype_Indication                 ;
VariableDeclE   . Variable_Declaration ::=            Variable              ":" Subtype_Indication  ":=" Expression;
VariableDeclI   . Variable_Declaration ::=            Variable  Identifier  ":" Subtype_Indication                 ;
VariableDeclIE  . Variable_Declaration ::=            Variable  Identifier  ":" Subtype_Indication  ":=" Expression;
VariableDeclS   . Variable_Declaration ::=  "shared"  Variable              ":" Subtype_Indication                 ;
VariableDeclSE  . Variable_Declaration ::=  "shared"  Variable              ":" Subtype_Indication  ":=" Expression;
VariableDeclSI  . Variable_Declaration ::=  "shared"  Variable  Identifier  ":" Subtype_Indication                 ;
VariableDeclSIE . Variable_Declaration ::=  "shared"  Variable  Identifier  ":" Subtype_Indication  ":=" Expression;

VerifiUnitBindInd . Verification_Unit_Binding_Indication ::=
                  "use" "vunit" Verification_Unit_List;

separator nonempty Verification_Unit_List ",";
_ . Verification_Unit_List ::= [Verification_Unit_Name];

WaitStmt     . Wait_Statement ::=             "wait"                                                         ;
WaitStmtT    . Wait_Statement ::=             "wait"                                          Timeout_Clause ;
WaitStmtC    . Wait_Statement ::=             "wait"                       Condition_Clause                  ;
WaitStmtCT   . Wait_Statement ::=             "wait"                       Condition_Clause   Timeout_Clause ;
WaitStmtS    . Wait_Statement ::=             "wait"  Sensitivity_Clause                                     ;
WaitStmtST   . Wait_Statement ::=             "wait"  Sensitivity_Clause                      Timeout_Clause ;
WaitStmtSC   . Wait_Statement ::=             "wait"  Sensitivity_Clause   Condition_Clause                  ;
WaitStmtSCT  . Wait_Statement ::=             "wait"  Sensitivity_Clause   Condition_Clause   Timeout_Clause ;
WaitStmtL    . Wait_Statement ::=  Label ":"  "wait"                                                         ;
WaitStmtLT   . Wait_Statement ::=  Label ":"  "wait"                                          Timeout_Clause ;
WaitStmtLC   . Wait_Statement ::=  Label ":"  "wait"                       Condition_Clause                  ;
WaitStmtLCT  . Wait_Statement ::=  Label ":"  "wait"                       Condition_Clause   Timeout_Clause ;
WaitStmtLS   . Wait_Statement ::=  Label ":"  "wait"  Sensitivity_Clause                                     ;
WaitStmtLST  . Wait_Statement ::=  Label ":"  "wait"  Sensitivity_Clause                      Timeout_Clause ;
WaitStmtLSC  . Wait_Statement ::=  Label ":"  "wait"  Sensitivity_Clause   Condition_Clause                  ;
WaitStmtLSCT . Wait_Statement ::=  Label ":"  "wait"  Sensitivity_Clause   Condition_Clause   Timeout_Clause ;

separator nonempty Waveform_Element ",";
WaveformList . Waveform ::= [Waveform_Element];
WaveformUnaffected . Waveform ::= "unaffected";

WaveElemValue . Waveform_Element ::= Value_Expression;
WaveElemValueAfter . Waveform_Element ::= Value_Expression "after" Time_Expression;
WaveElemNull . Waveform_Element ::= "null";
WaveElemNullAfter . Waveform_Element ::= "null" "after" Time_Expression;
