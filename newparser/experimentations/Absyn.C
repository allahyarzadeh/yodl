//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   NameSimple    ********************/
NameSimple::NameSimple(Simple_name *p1)
{
  simple_name_ = p1;

}

NameSimple::NameSimple(const NameSimple & other)
{
  simple_name_ = other.simple_name_->clone();

}

NameSimple &NameSimple::operator=(const NameSimple & other)
{
  NameSimple tmp(other);
  swap(tmp);
  return *this;
}

void NameSimple::swap(NameSimple & other)
{
  std::swap(simple_name_, other.simple_name_);

}

NameSimple::~NameSimple()
{
  delete(simple_name_);

}

void NameSimple::accept(Visitor *v)
{
  v->visitNameSimple(this);
}

NameSimple *NameSimple::clone() const
{
  return new NameSimple(*this);
}



/********************   NameOp    ********************/
NameOp::NameOp(Operator_symbol *p1)
{
  operator_symbol_ = p1;

}

NameOp::NameOp(const NameOp & other)
{
  operator_symbol_ = other.operator_symbol_->clone();

}

NameOp &NameOp::operator=(const NameOp & other)
{
  NameOp tmp(other);
  swap(tmp);
  return *this;
}

void NameOp::swap(NameOp & other)
{
  std::swap(operator_symbol_, other.operator_symbol_);

}

NameOp::~NameOp()
{
  delete(operator_symbol_);

}

void NameOp::accept(Visitor *v)
{
  v->visitNameOp(this);
}

NameOp *NameOp::clone() const
{
  return new NameOp(*this);
}



/********************   NameChar    ********************/
NameChar::NameChar(Character_literal *p1)
{
  character_literal_ = p1;

}

NameChar::NameChar(const NameChar & other)
{
  character_literal_ = other.character_literal_->clone();

}

NameChar &NameChar::operator=(const NameChar & other)
{
  NameChar tmp(other);
  swap(tmp);
  return *this;
}

void NameChar::swap(NameChar & other)
{
  std::swap(character_literal_, other.character_literal_);

}

NameChar::~NameChar()
{
  delete(character_literal_);

}

void NameChar::accept(Visitor *v)
{
  v->visitNameChar(this);
}

NameChar *NameChar::clone() const
{
  return new NameChar(*this);
}



/********************   NameSelected    ********************/
NameSelected::NameSelected(Selected_name *p1)
{
  selected_name_ = p1;

}

NameSelected::NameSelected(const NameSelected & other)
{
  selected_name_ = other.selected_name_->clone();

}

NameSelected &NameSelected::operator=(const NameSelected & other)
{
  NameSelected tmp(other);
  swap(tmp);
  return *this;
}

void NameSelected::swap(NameSelected & other)
{
  std::swap(selected_name_, other.selected_name_);

}

NameSelected::~NameSelected()
{
  delete(selected_name_);

}

void NameSelected::accept(Visitor *v)
{
  v->visitNameSelected(this);
}

NameSelected *NameSelected::clone() const
{
  return new NameSelected(*this);
}



/********************   NameIndexed    ********************/
NameIndexed::NameIndexed(Indexed_name *p1)
{
  indexed_name_ = p1;

}

NameIndexed::NameIndexed(const NameIndexed & other)
{
  indexed_name_ = other.indexed_name_->clone();

}

NameIndexed &NameIndexed::operator=(const NameIndexed & other)
{
  NameIndexed tmp(other);
  swap(tmp);
  return *this;
}

void NameIndexed::swap(NameIndexed & other)
{
  std::swap(indexed_name_, other.indexed_name_);

}

NameIndexed::~NameIndexed()
{
  delete(indexed_name_);

}

void NameIndexed::accept(Visitor *v)
{
  v->visitNameIndexed(this);
}

NameIndexed *NameIndexed::clone() const
{
  return new NameIndexed(*this);
}



/********************   NameSlice    ********************/
NameSlice::NameSlice(Slice_name *p1)
{
  slice_name_ = p1;

}

NameSlice::NameSlice(const NameSlice & other)
{
  slice_name_ = other.slice_name_->clone();

}

NameSlice &NameSlice::operator=(const NameSlice & other)
{
  NameSlice tmp(other);
  swap(tmp);
  return *this;
}

void NameSlice::swap(NameSlice & other)
{
  std::swap(slice_name_, other.slice_name_);

}

NameSlice::~NameSlice()
{
  delete(slice_name_);

}

void NameSlice::accept(Visitor *v)
{
  v->visitNameSlice(this);
}

NameSlice *NameSlice::clone() const
{
  return new NameSlice(*this);
}



/********************   NameAttr    ********************/
NameAttr::NameAttr(Attribute_name *p1)
{
  attribute_name_ = p1;

}

NameAttr::NameAttr(const NameAttr & other)
{
  attribute_name_ = other.attribute_name_->clone();

}

NameAttr &NameAttr::operator=(const NameAttr & other)
{
  NameAttr tmp(other);
  swap(tmp);
  return *this;
}

void NameAttr::swap(NameAttr & other)
{
  std::swap(attribute_name_, other.attribute_name_);

}

NameAttr::~NameAttr()
{
  delete(attribute_name_);

}

void NameAttr::accept(Visitor *v)
{
  v->visitNameAttr(this);
}

NameAttr *NameAttr::clone() const
{
  return new NameAttr(*this);
}



/********************   FunctionCallNyadic    ********************/
FunctionCallNyadic::FunctionCallNyadic(Name *p1)
{
  name_ = p1;

}

FunctionCallNyadic::FunctionCallNyadic(const FunctionCallNyadic & other)
{
  name_ = other.name_->clone();

}

FunctionCallNyadic &FunctionCallNyadic::operator=(const FunctionCallNyadic & other)
{
  FunctionCallNyadic tmp(other);
  swap(tmp);
  return *this;
}

void FunctionCallNyadic::swap(FunctionCallNyadic & other)
{
  std::swap(name_, other.name_);

}

FunctionCallNyadic::~FunctionCallNyadic()
{
  delete(name_);

}

void FunctionCallNyadic::accept(Visitor *v)
{
  v->visitFunctionCallNyadic(this);
}

FunctionCallNyadic *FunctionCallNyadic::clone() const
{
  return new FunctionCallNyadic(*this);
}



/********************   FunctionCallPolyadic    ********************/
FunctionCallPolyadic::FunctionCallPolyadic(Name *p1, ListAssociation_element *p2)
{
  name_ = p1;
  listassociation_element_ = p2;

}

FunctionCallPolyadic::FunctionCallPolyadic(const FunctionCallPolyadic & other)
{
  name_ = other.name_->clone();
  listassociation_element_ = other.listassociation_element_->clone();

}

FunctionCallPolyadic &FunctionCallPolyadic::operator=(const FunctionCallPolyadic & other)
{
  FunctionCallPolyadic tmp(other);
  swap(tmp);
  return *this;
}

void FunctionCallPolyadic::swap(FunctionCallPolyadic & other)
{
  std::swap(name_, other.name_);
  std::swap(listassociation_element_, other.listassociation_element_);

}

FunctionCallPolyadic::~FunctionCallPolyadic()
{
  delete(name_);
  delete(listassociation_element_);

}

void FunctionCallPolyadic::accept(Visitor *v)
{
  v->visitFunctionCallPolyadic(this);
}

FunctionCallPolyadic *FunctionCallPolyadic::clone() const
{
  return new FunctionCallPolyadic(*this);
}



/********************   AssocElementPositional    ********************/
AssocElementPositional::AssocElementPositional(Actual_part *p1)
{
  actual_part_ = p1;

}

AssocElementPositional::AssocElementPositional(const AssocElementPositional & other)
{
  actual_part_ = other.actual_part_->clone();

}

AssocElementPositional &AssocElementPositional::operator=(const AssocElementPositional & other)
{
  AssocElementPositional tmp(other);
  swap(tmp);
  return *this;
}

void AssocElementPositional::swap(AssocElementPositional & other)
{
  std::swap(actual_part_, other.actual_part_);

}

AssocElementPositional::~AssocElementPositional()
{
  delete(actual_part_);

}

void AssocElementPositional::accept(Visitor *v)
{
  v->visitAssocElementPositional(this);
}

AssocElementPositional *AssocElementPositional::clone() const
{
  return new AssocElementPositional(*this);
}



/********************   AssocElementNamedParam    ********************/
AssocElementNamedParam::AssocElementNamedParam(Name *p1, Actual_part *p2)
{
  name_ = p1;
  actual_part_ = p2;

}

AssocElementNamedParam::AssocElementNamedParam(const AssocElementNamedParam & other)
{
  name_ = other.name_->clone();
  actual_part_ = other.actual_part_->clone();

}

AssocElementNamedParam &AssocElementNamedParam::operator=(const AssocElementNamedParam & other)
{
  AssocElementNamedParam tmp(other);
  swap(tmp);
  return *this;
}

void AssocElementNamedParam::swap(AssocElementNamedParam & other)
{
  std::swap(name_, other.name_);
  std::swap(actual_part_, other.actual_part_);

}

AssocElementNamedParam::~AssocElementNamedParam()
{
  delete(name_);
  delete(actual_part_);

}

void AssocElementNamedParam::accept(Visitor *v)
{
  v->visitAssocElementNamedParam(this);
}

AssocElementNamedParam *AssocElementNamedParam::clone() const
{
  return new AssocElementNamedParam(*this);
}



/********************   ActualPartD    ********************/
ActualPartD::ActualPartD(Actual_designator *p1)
{
  actual_designator_ = p1;

}

ActualPartD::ActualPartD(const ActualPartD & other)
{
  actual_designator_ = other.actual_designator_->clone();

}

ActualPartD &ActualPartD::operator=(const ActualPartD & other)
{
  ActualPartD tmp(other);
  swap(tmp);
  return *this;
}

void ActualPartD::swap(ActualPartD & other)
{
  std::swap(actual_designator_, other.actual_designator_);

}

ActualPartD::~ActualPartD()
{
  delete(actual_designator_);

}

void ActualPartD::accept(Visitor *v)
{
  v->visitActualPartD(this);
}

ActualPartD *ActualPartD::clone() const
{
  return new ActualPartD(*this);
}



/********************   ActualFoo    ********************/
ActualFoo::ActualFoo(Name *p1, Actual_designator *p2)
{
  name_ = p1;
  actual_designator_ = p2;

}

ActualFoo::ActualFoo(const ActualFoo & other)
{
  name_ = other.name_->clone();
  actual_designator_ = other.actual_designator_->clone();

}

ActualFoo &ActualFoo::operator=(const ActualFoo & other)
{
  ActualFoo tmp(other);
  swap(tmp);
  return *this;
}

void ActualFoo::swap(ActualFoo & other)
{
  std::swap(name_, other.name_);
  std::swap(actual_designator_, other.actual_designator_);

}

ActualFoo::~ActualFoo()
{
  delete(name_);
  delete(actual_designator_);

}

void ActualFoo::accept(Visitor *v)
{
  v->visitActualFoo(this);
}

ActualFoo *ActualFoo::clone() const
{
  return new ActualFoo(*this);
}



/********************   ExpressionName    ********************/
ExpressionName::ExpressionName(Name *p1)
{
  name_ = p1;

}

ExpressionName::ExpressionName(const ExpressionName & other)
{
  name_ = other.name_->clone();

}

ExpressionName &ExpressionName::operator=(const ExpressionName & other)
{
  ExpressionName tmp(other);
  swap(tmp);
  return *this;
}

void ExpressionName::swap(ExpressionName & other)
{
  std::swap(name_, other.name_);

}

ExpressionName::~ExpressionName()
{
  delete(name_);

}

void ExpressionName::accept(Visitor *v)
{
  v->visitExpressionName(this);
}

ExpressionName *ExpressionName::clone() const
{
  return new ExpressionName(*this);
}



/********************   ExpressionNumber    ********************/
ExpressionNumber::ExpressionNumber(Integer p1)
{
  integer_ = p1;

}

ExpressionNumber::ExpressionNumber(const ExpressionNumber & other)
{
  integer_ = other.integer_;

}

ExpressionNumber &ExpressionNumber::operator=(const ExpressionNumber & other)
{
  ExpressionNumber tmp(other);
  swap(tmp);
  return *this;
}

void ExpressionNumber::swap(ExpressionNumber & other)
{
  std::swap(integer_, other.integer_);

}

ExpressionNumber::~ExpressionNumber()
{

}

void ExpressionNumber::accept(Visitor *v)
{
  v->visitExpressionNumber(this);
}

ExpressionNumber *ExpressionNumber::clone() const
{
  return new ExpressionNumber(*this);
}



/********************   ExpressionDesignator    ********************/
ExpressionDesignator::ExpressionDesignator(Expression *p1)
{
  expression_ = p1;

}

ExpressionDesignator::ExpressionDesignator(const ExpressionDesignator & other)
{
  expression_ = other.expression_->clone();

}

ExpressionDesignator &ExpressionDesignator::operator=(const ExpressionDesignator & other)
{
  ExpressionDesignator tmp(other);
  swap(tmp);
  return *this;
}

void ExpressionDesignator::swap(ExpressionDesignator & other)
{
  std::swap(expression_, other.expression_);

}

ExpressionDesignator::~ExpressionDesignator()
{
  delete(expression_);

}

void ExpressionDesignator::accept(Visitor *v)
{
  v->visitExpressionDesignator(this);
}

ExpressionDesignator *ExpressionDesignator::clone() const
{
  return new ExpressionDesignator(*this);
}



/********************   NameDesignator    ********************/
NameDesignator::NameDesignator(Name *p1)
{
  name_ = p1;

}

NameDesignator::NameDesignator(const NameDesignator & other)
{
  name_ = other.name_->clone();

}

NameDesignator &NameDesignator::operator=(const NameDesignator & other)
{
  NameDesignator tmp(other);
  swap(tmp);
  return *this;
}

void NameDesignator::swap(NameDesignator & other)
{
  std::swap(name_, other.name_);

}

NameDesignator::~NameDesignator()
{
  delete(name_);

}

void NameDesignator::accept(Visitor *v)
{
  v->visitNameDesignator(this);
}

NameDesignator *NameDesignator::clone() const
{
  return new NameDesignator(*this);
}



/********************   NamePrefix    ********************/
NamePrefix::NamePrefix(Name *p1)
{
  name_ = p1;

}

NamePrefix::NamePrefix(const NamePrefix & other)
{
  name_ = other.name_->clone();

}

NamePrefix &NamePrefix::operator=(const NamePrefix & other)
{
  NamePrefix tmp(other);
  swap(tmp);
  return *this;
}

void NamePrefix::swap(NamePrefix & other)
{
  std::swap(name_, other.name_);

}

NamePrefix::~NamePrefix()
{
  delete(name_);

}

void NamePrefix::accept(Visitor *v)
{
  v->visitNamePrefix(this);
}

NamePrefix *NamePrefix::clone() const
{
  return new NamePrefix(*this);
}



/********************   FunctionPrefix    ********************/
FunctionPrefix::FunctionPrefix(Function_call *p1)
{
  function_call_ = p1;

}

FunctionPrefix::FunctionPrefix(const FunctionPrefix & other)
{
  function_call_ = other.function_call_->clone();

}

FunctionPrefix &FunctionPrefix::operator=(const FunctionPrefix & other)
{
  FunctionPrefix tmp(other);
  swap(tmp);
  return *this;
}

void FunctionPrefix::swap(FunctionPrefix & other)
{
  std::swap(function_call_, other.function_call_);

}

FunctionPrefix::~FunctionPrefix()
{
  delete(function_call_);

}

void FunctionPrefix::accept(Visitor *v)
{
  v->visitFunctionPrefix(this);
}

FunctionPrefix *FunctionPrefix::clone() const
{
  return new FunctionPrefix(*this);
}



/********************   SelectedName    ********************/
SelectedName::SelectedName(Prefix *p1, Suffix *p2)
{
  prefix_ = p1;
  suffix_ = p2;

}

SelectedName::SelectedName(const SelectedName & other)
{
  prefix_ = other.prefix_->clone();
  suffix_ = other.suffix_->clone();

}

SelectedName &SelectedName::operator=(const SelectedName & other)
{
  SelectedName tmp(other);
  swap(tmp);
  return *this;
}

void SelectedName::swap(SelectedName & other)
{
  std::swap(prefix_, other.prefix_);
  std::swap(suffix_, other.suffix_);

}

SelectedName::~SelectedName()
{
  delete(prefix_);
  delete(suffix_);

}

void SelectedName::accept(Visitor *v)
{
  v->visitSelectedName(this);
}

SelectedName *SelectedName::clone() const
{
  return new SelectedName(*this);
}



/********************   AllSuffix    ********************/
AllSuffix::AllSuffix()
{

}

AllSuffix::AllSuffix(const AllSuffix & other)
{

}

AllSuffix &AllSuffix::operator=(const AllSuffix & other)
{
  AllSuffix tmp(other);
  swap(tmp);
  return *this;
}

void AllSuffix::swap(AllSuffix & other)
{

}

AllSuffix::~AllSuffix()
{

}

void AllSuffix::accept(Visitor *v)
{
  v->visitAllSuffix(this);
}

AllSuffix *AllSuffix::clone() const
{
  return new AllSuffix(*this);
}



/********************   AllSuffixfoo    ********************/
AllSuffixfoo::AllSuffixfoo()
{

}

AllSuffixfoo::AllSuffixfoo(const AllSuffixfoo & other)
{

}

AllSuffixfoo &AllSuffixfoo::operator=(const AllSuffixfoo & other)
{
  AllSuffixfoo tmp(other);
  swap(tmp);
  return *this;
}

void AllSuffixfoo::swap(AllSuffixfoo & other)
{

}

AllSuffixfoo::~AllSuffixfoo()
{

}

void AllSuffixfoo::accept(Visitor *v)
{
  v->visitAllSuffixfoo(this);
}

AllSuffixfoo *AllSuffixfoo::clone() const
{
  return new AllSuffixfoo(*this);
}



/********************   NameSuffix    ********************/
NameSuffix::NameSuffix(Simple_name *p1)
{
  simple_name_ = p1;

}

NameSuffix::NameSuffix(const NameSuffix & other)
{
  simple_name_ = other.simple_name_->clone();

}

NameSuffix &NameSuffix::operator=(const NameSuffix & other)
{
  NameSuffix tmp(other);
  swap(tmp);
  return *this;
}

void NameSuffix::swap(NameSuffix & other)
{
  std::swap(simple_name_, other.simple_name_);

}

NameSuffix::~NameSuffix()
{
  delete(simple_name_);

}

void NameSuffix::accept(Visitor *v)
{
  v->visitNameSuffix(this);
}

NameSuffix *NameSuffix::clone() const
{
  return new NameSuffix(*this);
}



/********************   AttributeName    ********************/
AttributeName::AttributeName(Prefix *p1, Name *p2)
{
  prefix_ = p1;
  name_ = p2;

}

AttributeName::AttributeName(const AttributeName & other)
{
  prefix_ = other.prefix_->clone();
  name_ = other.name_->clone();

}

AttributeName &AttributeName::operator=(const AttributeName & other)
{
  AttributeName tmp(other);
  swap(tmp);
  return *this;
}

void AttributeName::swap(AttributeName & other)
{
  std::swap(prefix_, other.prefix_);
  std::swap(name_, other.name_);

}

AttributeName::~AttributeName()
{
  delete(prefix_);
  delete(name_);

}

void AttributeName::accept(Visitor *v)
{
  v->visitAttributeName(this);
}

AttributeName *AttributeName::clone() const
{
  return new AttributeName(*this);
}



/********************   SliceName    ********************/
SliceName::SliceName(Prefix *p1, Expression *p2)
{
  prefix_ = p1;
  expression_ = p2;

}

SliceName::SliceName(const SliceName & other)
{
  prefix_ = other.prefix_->clone();
  expression_ = other.expression_->clone();

}

SliceName &SliceName::operator=(const SliceName & other)
{
  SliceName tmp(other);
  swap(tmp);
  return *this;
}

void SliceName::swap(SliceName & other)
{
  std::swap(prefix_, other.prefix_);
  std::swap(expression_, other.expression_);

}

SliceName::~SliceName()
{
  delete(prefix_);
  delete(expression_);

}

void SliceName::accept(Visitor *v)
{
  v->visitSliceName(this);
}

SliceName *SliceName::clone() const
{
  return new SliceName(*this);
}



/********************   IndexedName    ********************/
IndexedName::IndexedName(Prefix *p1, ListExpression *p2)
{
  prefix_ = p1;
  listexpression_ = p2;

}

IndexedName::IndexedName(const IndexedName & other)
{
  prefix_ = other.prefix_->clone();
  listexpression_ = other.listexpression_->clone();

}

IndexedName &IndexedName::operator=(const IndexedName & other)
{
  IndexedName tmp(other);
  swap(tmp);
  return *this;
}

void IndexedName::swap(IndexedName & other)
{
  std::swap(prefix_, other.prefix_);
  std::swap(listexpression_, other.listexpression_);

}

IndexedName::~IndexedName()
{
  delete(prefix_);
  delete(listexpression_);

}

void IndexedName::accept(Visitor *v)
{
  v->visitIndexedName(this);
}

IndexedName *IndexedName::clone() const
{
  return new IndexedName(*this);
}



/********************   CharLiteral    ********************/
CharLiteral::CharLiteral(Char p1)
{
  char_ = p1;

}

CharLiteral::CharLiteral(const CharLiteral & other)
{
  char_ = other.char_;

}

CharLiteral &CharLiteral::operator=(const CharLiteral & other)
{
  CharLiteral tmp(other);
  swap(tmp);
  return *this;
}

void CharLiteral::swap(CharLiteral & other)
{
  std::swap(char_, other.char_);

}

CharLiteral::~CharLiteral()
{

}

void CharLiteral::accept(Visitor *v)
{
  v->visitCharLiteral(this);
}

CharLiteral *CharLiteral::clone() const
{
  return new CharLiteral(*this);
}



/********************   GraphicChar    ********************/
GraphicChar::GraphicChar(Char p1)
{
  char_ = p1;

}

GraphicChar::GraphicChar(const GraphicChar & other)
{
  char_ = other.char_;

}

GraphicChar &GraphicChar::operator=(const GraphicChar & other)
{
  GraphicChar tmp(other);
  swap(tmp);
  return *this;
}

void GraphicChar::swap(GraphicChar & other)
{
  std::swap(char_, other.char_);

}

GraphicChar::~GraphicChar()
{

}

void GraphicChar::accept(Visitor *v)
{
  v->visitGraphicChar(this);
}

GraphicChar *GraphicChar::clone() const
{
  return new GraphicChar(*this);
}



/********************   OperatorSymbol    ********************/
OperatorSymbol::OperatorSymbol(String p1)
{
  string_ = p1;

}

OperatorSymbol::OperatorSymbol(const OperatorSymbol & other)
{
  string_ = other.string_;

}

OperatorSymbol &OperatorSymbol::operator=(const OperatorSymbol & other)
{
  OperatorSymbol tmp(other);
  swap(tmp);
  return *this;
}

void OperatorSymbol::swap(OperatorSymbol & other)
{
  std::swap(string_, other.string_);

}

OperatorSymbol::~OperatorSymbol()
{

}

void OperatorSymbol::accept(Visitor *v)
{
  v->visitOperatorSymbol(this);
}

OperatorSymbol *OperatorSymbol::clone() const
{
  return new OperatorSymbol(*this);
}



/********************   SimpleName    ********************/
SimpleName::SimpleName(Ident p1)
{
  ident_ = p1;

}

SimpleName::SimpleName(const SimpleName & other)
{
  ident_ = other.ident_;

}

SimpleName &SimpleName::operator=(const SimpleName & other)
{
  SimpleName tmp(other);
  swap(tmp);
  return *this;
}

void SimpleName::swap(SimpleName & other)
{
  std::swap(ident_, other.ident_);

}

SimpleName::~SimpleName()
{

}

void SimpleName::accept(Visitor *v)
{
  v->visitSimpleName(this);
}

SimpleName *SimpleName::clone() const
{
  return new SimpleName(*this);
}




/********************   ListAssociation_element    ********************/

void ListAssociation_element::accept(Visitor *v)
{
  v->visitListAssociation_element(this);
}


ListAssociation_element *ListAssociation_element::clone() const
{
  return new ListAssociation_element(*this);
}


/********************   ListExpression    ********************/

void ListExpression::accept(Visitor *v)
{
  v->visitListExpression(this);
}


ListExpression *ListExpression::clone() const
{
  return new ListExpression(*this);
}




